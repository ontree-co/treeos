---
# OnTreeNode Initial Production Install Playbook
# This playbook performs the initial installation of OnTreeNode Go application from GitHub Releases.
# It creates a dedicated user, downloads the binary from the latest release,
# runs database migrations, and runs the app as a systemd service.
# Prerequisites:
# - GitHub repository with releases (public or with appropriate access token)
# - Target servers must have sudo access and internet connectivity
# Usage: ansible-playbook -i inventory.ini ontreenode-initial-production-install-playbook.yaml

- name: Initial installation of OnTreeNode production service
  hosts: ontreenodes
  become: yes

  vars:
    github_repo: "stefanmunz/treeos" # GitHub owner/repo
    github_token: "{{ lookup('env', 'GITHUB_ONTREE_DEPLOY_KEY') }}" # GitHub token from environment
    app_name: "treeos"
    app_user: "ontree"
    app_root_dir: "/opt/ontree"
    app_path: "{{ app_root_dir }}/treeos"
    app_port: 3000
    ansible_common_remote_group: "{{ app_user }}"
    binary_name: "treeos"
    # Detect architecture
    arch_map:
      x86_64: "x86_64"
      aarch64: "arm64"
    target_arch: "{{ arch_map[ansible_architecture] | default(ansible_architecture) }}"

  handlers:
    - name: reload systemd
      ansible.builtin.systemd:
        daemon_reload: yes

  tasks:
    # Phase 0: Get latest release version
    - name: Get latest release from GitHub API
      ansible.builtin.uri:
        url: "https://api.github.com/repos/{{ github_repo }}/releases/latest"
        method: GET
        headers:
          Accept: "application/vnd.github.v3+json"
          Authorization: "token {{ github_token }}"
      register: latest_release
    
    - name: Set release version from latest
      set_fact:
        release_version: "{{ latest_release.json.tag_name }}"
    
    - name: Display version to be installed
      ansible.builtin.debug:
        msg: "Installing latest version: {{ release_version }}"

    # Phase 1: System Preparation
    - name: Update package cache
      ansible.builtin.package:
        update_cache: yes

    - name: Install system dependencies
      ansible.builtin.package:
        name:
          - acl
          - wget
          - tar
        state: present
      register: package_install
      failed_when: package_install.failed

    - name: Create dedicated application user
      ansible.builtin.user:
        name: "{{ app_user }}"
        system: yes
        shell: /bin/bash
        home: "/home/{{ app_user }}"
        create_home: yes
        comment: "User for {{ app_name }} application"

    - name: Create application directory
      ansible.builtin.file:
        path: "{{ app_path }}"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0775"

    - name: Create apps directory for container management
      ansible.builtin.file:
        path: "{{ app_root_dir }}/apps"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0775"

    # Phase 2: Binary Deployment
    - name: Stop ontreenode service before updating
      ansible.builtin.systemd:
        name: "{{ app_name }}"
        state: stopped
      ignore_errors: yes # Service might not exist on first run

    - name: Get release information from GitHub API
      ansible.builtin.uri:
        url: "https://api.github.com/repos/{{ github_repo }}/releases/tags/{{ release_version }}"
        method: GET
        headers:
          Accept: "application/vnd.github.v3+json"
          Authorization: "token {{ github_token }}"
      register: release_info

    - name: Set expected filename
      set_fact:
        expected_filename: "treeos_{{ release_version | regex_replace('^v', '') }}_linux_{{ target_arch }}.tar.gz"
    
    - name: Find the correct asset URL
      set_fact:
        asset_url: "{{ item.url }}"
      loop: "{{ release_info.json.assets }}"
      when: item.name == expected_filename

    - name: Download release binary from GitHub API
      ansible.builtin.uri:
        url: "{{ asset_url }}"
        method: GET
        headers:
          Authorization: "token {{ github_token }}"
          Accept: "application/octet-stream"
        dest: "/tmp/{{ binary_name }}_{{ release_version }}.tar.gz"
        follow_redirects: all
      register: download_result

    - name: Extract binary
      ansible.builtin.unarchive:
        src: "/tmp/{{ binary_name }}_{{ release_version }}.tar.gz"
        dest: "{{ app_path }}"
        remote_src: yes
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0755"
      when: download_result is succeeded

    - name: Ensure binary is executable
      ansible.builtin.file:
        path: "{{ app_path }}/{{ binary_name }}"
        mode: "0755"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"

    - name: Create migrations directory
      ansible.builtin.file:
        path: "{{ app_path }}/migrations"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0755"

    - name: Get list of migration files from repository
      ansible.builtin.uri:
        url: "https://api.github.com/repos/{{ github_repo }}/contents/migrations?ref={{ release_version }}"
        method: GET
        headers:
          Accept: "application/vnd.github.v3+json"
          Authorization: "token {{ github_token }}"
      register: migration_files

    - name: Download all migration files
      ansible.builtin.get_url:
        url: "https://raw.githubusercontent.com/{{ github_repo }}/{{ release_version }}/migrations/{{ item.name }}"
        dest: "{{ app_path }}/migrations/{{ item.name }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0644"
        headers:
          Authorization: "token {{ github_token }}"
      loop: "{{ migration_files.json }}"
      when: item.type == 'file' and item.name.endswith('.sql')

    # Phase 3: Database Migrations
    - name: Check if goose is installed
      ansible.builtin.command:
        cmd: which goose
      register: goose_check
      ignore_errors: yes
      changed_when: false

    - name: Install goose if not present
      ansible.builtin.get_url:
        url: "https://github.com/pressly/goose/releases/download/v3.15.1/goose_linux_{{ target_arch }}"
        dest: "/usr/local/bin/goose"
        mode: "0755"
      when: goose_check.rc != 0

    - name: Run database migrations
      ansible.builtin.command:
        cmd: "goose -dir {{ app_path }}/migrations sqlite3 {{ app_path }}/ontree.db up"
      become_user: "{{ app_user }}"
      register: migration_result
      changed_when: "'migration' in migration_result.stdout"

    # Phase 4: Port Availability Check
    - name: Check if port {{ app_port }} is available
      ansible.builtin.wait_for:
        port: "{{ app_port }}"
        state: stopped
        timeout: 5
      register: port_check
      ignore_errors: yes

    - name: Fail if port is already in use
      ansible.builtin.fail:
        msg: "Port {{ app_port }} is already in use. This might be the development version of {{ app_name }} still running. Please stop it with 'systemctl stop {{ app_name }}-dev' or choose a different port."
      when: port_check.failed

    # Phase 5: Caddy Health Check (Optional)
    # Commented out - Caddy can be installed separately if needed
    # - name: Check if Caddy is accessible
    #   ansible.builtin.uri:
    #     url: "http://localhost:2019/"
    #     method: GET
    #     status_code: 200
    #     timeout: 5
    #   register: caddy_health_check
    #   ignore_errors: yes

    # - name: Fail if Caddy is not running or accessible
    #   ansible.builtin.fail:
    #     msg: "Cannot connect to Caddy Admin API at localhost:2019. Please ensure Caddy is installed and running."
    #   when: caddy_health_check.failed or caddy_health_check.status != 200

    # Phase 6: Service Configuration
    - name: Create systemd service file
      ansible.builtin.template:
        src: ontreenode.service.j2
        dest: "/etc/systemd/system/{{ app_name }}.service"
        owner: root
        group: root
        mode: "0644"
      notify: reload systemd

    # Phase 7: Service Management
    - name: Enable and restart application service
      ansible.builtin.systemd:
        name: "{{ app_name }}"
        enabled: yes
        state: restarted
        daemon_reload: yes

    - name: Check service health
      ansible.builtin.uri:
        url: "http://localhost:{{ app_port }}/"
        method: GET
        status_code: [200, 301, 302]
        timeout: 5
      register: health_check
      retries: 3
      delay: 10
      until: health_check.status in [200, 301, 302]

    - name: Display initial installation status
      ansible.builtin.debug:
        msg:
          - "âœ… Initial production installation completed!"
          - "{{ app_name }} service is running on {{ inventory_hostname }}:{{ app_port }}"
          - "Installed version: {{ release_version }}"
          - ""
          - "For future updates, use: ansible-playbook -i inventory.ini ontreenode-update-playbook.yaml"
