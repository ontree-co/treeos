---
# OnTreeNode Enable Production Playbook
# This playbook deploys the OnTreeNode Go application from GitHub Releases.
# It creates a dedicated user, downloads the binary from the latest release,
# runs database migrations, and runs the app as a systemd service.
# Prerequisites:
# - GitHub repository with releases (public or with appropriate access token)
# - Target servers must have sudo access and internet connectivity
# Usage: ansible-playbook -i inventory.ini ontreenode-enable-production-playbook.yaml

- name: Deploy and enable OnTreeNode production service
  hosts: ontreenodes
  become: yes

  vars:
    github_repo: "stefanmunz/ontree-node" # GitHub owner/repo
    release_version: "v0.1.0" # Version to deploy
    app_name: "ontreenode"
    app_user: "ontree"
    app_root_dir: "/opt/ontree"
    app_path: "{{ app_root_dir }}/{{ app_name }}"
    app_port: 3000
    ansible_common_remote_group: "{{ app_user }}"
    binary_name: "ontree-server"
    # Detect architecture
    arch_map:
      x86_64: "x86_64"
      aarch64: "arm64"
    target_arch: "{{ arch_map[ansible_architecture] | default(ansible_architecture) }}"

  handlers:
    - name: reload systemd
      ansible.builtin.systemd:
        daemon_reload: yes

  tasks:
    # Phase 1: System Preparation
    - name: Update package cache
      ansible.builtin.package:
        update_cache: yes

    - name: Install system dependencies
      ansible.builtin.package:
        name:
          - acl
          - wget
          - tar
        state: present
      register: package_install
      failed_when: package_install.failed

    - name: Create dedicated application user
      ansible.builtin.user:
        name: "{{ app_user }}"
        system: yes
        shell: /bin/bash
        home: "/home/{{ app_user }}"
        create_home: yes
        comment: "User for {{ app_name }} application"

    - name: Create application directory
      ansible.builtin.file:
        path: "{{ app_path }}"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0775"

    - name: Create apps directory for container management
      ansible.builtin.file:
        path: "{{ app_root_dir }}/apps"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0775"

    # Phase 2: Binary Deployment
    - name: Stop ontreenode service before updating
      ansible.builtin.systemd:
        name: "{{ app_name }}"
        state: stopped
      ignore_errors: yes # Service might not exist on first run

    - name: Set download URL for the binary
      set_fact:
        download_url: "https://github.com/{{ github_repo }}/releases/download/{{ release_version }}/ontree-server_{{ release_version | regex_replace('^v', '') }}_linux_{{ target_arch }}.tar.gz"

    - name: Download release binary
      ansible.builtin.get_url:
        url: "{{ download_url }}"
        dest: "/tmp/{{ binary_name }}_{{ release_version }}.tar.gz"
        mode: '0644'
      register: download_result

    - name: Extract binary
      ansible.builtin.unarchive:
        src: "/tmp/{{ binary_name }}_{{ release_version }}.tar.gz"
        dest: "{{ app_path }}"
        remote_src: yes
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0755'
      when: download_result is succeeded

    - name: Ensure binary is executable
      ansible.builtin.file:
        path: "{{ app_path }}/{{ binary_name }}"
        mode: '0755'
        owner: "{{ app_user }}"
        group: "{{ app_user }}"

    - name: Create migrations directory
      ansible.builtin.file:
        path: "{{ app_path }}/migrations"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: "0755"

    - name: Get list of migration files from repository
      ansible.builtin.uri:
        url: "https://api.github.com/repos/{{ github_repo }}/contents/migrations?ref={{ release_version }}"
        method: GET
        headers:
          Accept: "application/vnd.github.v3+json"
      register: migration_files

    - name: Download all migration files
      ansible.builtin.get_url:
        url: "https://raw.githubusercontent.com/{{ github_repo }}/{{ release_version }}/migrations/{{ item.name }}"
        dest: "{{ app_path }}/migrations/{{ item.name }}"
        owner: "{{ app_user }}"
        group: "{{ app_user }}"
        mode: '0644'
      loop: "{{ migration_files.json }}"
      when: item.type == 'file' and item.name.endswith('.sql')

    # Phase 3: Database Migrations
    - name: Check if goose is installed
      ansible.builtin.command:
        cmd: which goose
      register: goose_check
      ignore_errors: yes
      changed_when: false

    - name: Install goose if not present
      ansible.builtin.get_url:
        url: "https://github.com/pressly/goose/releases/download/v3.15.1/goose_linux_{{ target_arch }}"
        dest: "/usr/local/bin/goose"
        mode: '0755'
      when: goose_check.rc != 0

    - name: Run database migrations
      ansible.builtin.command:
        cmd: "goose -dir {{ app_path }}/migrations sqlite3 {{ app_path }}/ontree.db up"
      become_user: "{{ app_user }}"
      register: migration_result
      changed_when: "'migration' in migration_result.stdout"

    # Phase 4: Port Availability Check
    - name: Check if port {{ app_port }} is available
      ansible.builtin.wait_for:
        port: "{{ app_port }}"
        state: stopped
        timeout: 5
      register: port_check
      ignore_errors: yes

    - name: Fail if port is already in use
      ansible.builtin.fail:
        msg: "Port {{ app_port }} is already in use. This might be the development version of {{ app_name }} still running. Please stop it with 'systemctl stop {{ app_name }}-dev' or choose a different port."
      when: port_check.failed

    # Phase 5: Caddy Health Check
    - name: Check if Caddy is accessible
      ansible.builtin.uri:
        url: "http://localhost:2019/"
        method: GET
        status_code: 200
        timeout: 5
      register: caddy_health_check
      ignore_errors: yes

    - name: Fail if Caddy is not running or accessible
      ansible.builtin.fail:
        msg: "Cannot connect to Caddy Admin API at localhost:2019. Please ensure Caddy is installed and running."
      when: caddy_health_check.failed or caddy_health_check.status != 200

    # Phase 6: Service Configuration
    - name: Create systemd service file
      ansible.builtin.template:
        src: ontreenode.service.j2
        dest: "/etc/systemd/system/{{ app_name }}.service"
        owner: root
        group: root
        mode: "0644"
      notify: reload systemd

    # Phase 7: Service Management
    - name: Enable and restart application service
      ansible.builtin.systemd:
        name: "{{ app_name }}"
        enabled: yes
        state: restarted
        daemon_reload: yes

    - name: Check service health
      ansible.builtin.uri:
        url: "http://localhost:{{ app_port }}/"
        method: GET
        status_code: [200, 301, 302]
        timeout: 5
      register: health_check
      retries: 3
      delay: 10
      until: health_check.status in [200, 301, 302]

    - name: Display production deployment status
      ansible.builtin.debug:
        msg:
          - "âœ… Production deployment completed!"
          - "{{ app_name }} service is running on {{ inventory_hostname }}:{{ app_port }}"
          - "Deployed version: {{ release_version }}"
          - ""
          - "To switch to development mode, run: ansible-playbook -i inventory.ini ontreenode-allow-local-development-playbook.yaml"
